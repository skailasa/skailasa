Iâ€™m Computational Mathematics PhD Student at University College London, currently focussed on becoming rusty ðŸ¦€.

Iâ€™m interested in taking advantage of mathematics, parallel & distributed computing, software engineering, and heterogenous compute environments to solve problems in science. I have been core developer on two moderately sized open source softwares, where I explored techniques to extract as much performance with Python and it's ample high performance stack as possible:

- [PyExaFMM](https://github.com/exafmm/pyexafmm) - a Python library for Fast Multipole Methods.
- [AdaptOctree](https://github.com/Excalibur-SLE/AdaptOctree) - a Python library for building & balancing linear Octrees


As I'm working on a few different scientific (i.e. highly niche) codebases at any one time, I've been trying to cut out pieces of what I consider to be the most generically useful implementations, which as far as I know don't exist in the presented form.

So far I have:
- [PyRSVD](https://github.com/skailasa/pyrsvd) - a Python library for computing the Randomised SVD of Halko et al, on dense matrices, accellerated using CUDA.
- [PyFastInvSqrt](https://github.com/skailasa/pyinvsqrt) - a Python library offering an interface to the original Quake 3 inverse square root algorithm.
